<html><body><textarea id=$_1 style=width:1px;height:1px>{"orgnum":0,āriginalurlĈ"https://zhongyanlĐ.ďthub.io/siteĴĢwcase"ċĆltoolstyleĵdĈąllŁmŃŅŇŉŋshrefŏuőċļchedfģtfamilyėĐťčtŀ"cņĂsĈ["blackŶŜŎċgŜenŶĂħgĿċſuƐ"pĔpŋŶpĐƃċ#BƠB00"]ƑŸlźż"whĶƔƅŶƈeƊƌrƎƔƒƔƖrƘƻƜŶĩgęyeőowŶtƷnspaŜnŵċ1ƥċfŮƊŬĿ:"202ǟ126.ęŔŶnƴdǋħsƀńrĈǋƓċŦĶaſǜǴeċtňmpĈ6775446ċŚapeǐǲ:[Ž'Ȑay isșncŜĽĐgů sĂķd <=> Ũr ħȘǏir\ni,jȜ [Ċ N-1Ʀi<j,ȶx[i]ȩ ɉjɌȪȬȮ kȜȶȽ,ɀ2ƦɎ[kɑɕɟ+ɂȶɈɟɌħȨɉkɤɌȚ ļőŦȰdjƁƊt ȳȵnȶbŖȏnșsSȦŦ(Đɺ[ɩrƷy){.ʓ}',,čǃǋect,487,35,598,ǡ3ʣĊ'0ʖʯʖĊ0.ƣʴ,ʵʷ,'ŲeŴʖūŇǽƤċ'ɔȖȘə 4, Ȋ ʩ 11ˎ1ʬ˓6ɝɪ tǐƏɺ9ˎɻʿȮm bĐǐȘľǐŤȰnȨwŴe dǈn.  ƩwˎƮǃ ˎŭddŋ˰ȨvĒƓȭĂ ȏ˯ƯƷtĲnʖʘĎęŜʝ,7Ȋ4ʥ88ˢ˔˕3ʮʰʼ̩ʴʶƣ,˕1̭ʮʾˀ,˂ľʹŶʗʙ̚ʜʞǣĊǟĊ4̮15Ç̪̇ʱ̫ʹ̲ʣʣ͎ʽnųĶˁĒ̸˅"'ŗșķ̓̕:ȶ˽ = Ⱦ̀hͤˏȶ̄̆˵ͥ(0+6)/2ͪ3ȶ̊ēͯˑȶŸȁǐ˵8 wĶͩ9ȶĵȝ˵9>˒Ǫvʿ˨˵Đ˝ťȭȴň hĒfˎͣͥͭŋɤͪ4ȶ̗̼ʛ̜85ʩǤʥ70ʬ25ʥ͉ʲ͊ʹ͍ʻ2ʪ̴̶͕͑͗˄ŶĊ,cȴcŋ,-ˢ2̢ʣ˕Ȅʦ̨ʱ3ʳμ̮ˍ4π͓ʿς̷υċˍψϊό10ʥ29ˍ͉ϔ͇κ'ϘλʺϛʟϞ͔t͖˃̹ċȊϦrϋǽ21ί9ʢ3ϓʢϱιϳϙ϶̓ϸʻ͒Ϻϼ͘ŶʩЁЃʣ3δ9̦Ċϰϖʼϴ̬ʻϜϹϠϻσϽ͙˔ʗωЂόȈʢϬʬ5ȊУϲЦϚВϝДρЬϢϾ"˗бϧǽйξϐʥή,лЎнБʟГ̮ЕЫЗϣцЀвМ68ˍϐʩяё̩Џϵ͎Щсϟ̵ф͙'↑ȶMΩou˱̛ʞȉ˕ȇʬ̠̯2иФ'6А͎а˔ЪѮτхѱȶLѵѷdѹʟ7̦Јʭ̯аѿЎ҅ѩʻ҈̱ѬЖЭИˆѲnHґѸ̾ʣ5ξ3Рʣʩǣ҂ϲҞЧͅʬ˗ҊϡҌ͙ˢЛό͇ю5̦Ћϕϲ1҆Ҡˍ1рїтњхχrѶҬ̜ϩʪ̮ϐѐ̓ʥЎ2ӌͅʥ͆ҽуҿŶ˕ʘӗғҭǣж0Ѣʩ6ӟϲӢҟӤ̯5ӧӓ͙ξӬҒҔҁѢӜӴӶӡӣĊ͆ӻӽҥћʬԁӘʞʤδγʪԇʟӠѧӸҹԋӥӼңљԏхϥӖԂҭ47Ԗ˕ӝӵԚӷԊӻԍԢҋЮŶʥԒӮ̜ʧξ1ҘԮԈԜԲԌӦԵҾԷϿ̻ӭҔҖȊǢԘӞ԰ԉӹԟԴӑѭՈИ]Ʀ"ĩǪȐżʌ՝cĔΒաȒգċaĚƁhňȑ"ŶȌȎ̔mǜʌċ՟eնոդզռiշż՝ǏˠւվիőiŌբ՜ƑgըŽǖ"kfƷշŻ:{}ċkմ֍ȒօaƏ1հėˉʄȜȞȏ΋ȢˬʇȨɒ̍ȯȱɻaȴȶȸȺΖˋɀɂ,ɄɆɧɋɍɏɑȫִɕɗnəɛɝɬɡkɣɥɾnב̈ɞɭɂ֪ɲŋȨaɶɸǒַֹזʀņʂʄʆrȧʉפʌȰʎȗʑʓ.}<br>ˈ׳ˊȾˍˏˎ˒а˓˘1˚ˎ˜˞ăռ ˢ˻Ȏr˦˨˪rˬȏЂͩ˜˳Ư˶˸˺˼ǈ˿̙̂ Σ˵˜ͻ̌ɔ̐ͩ̒լ̕׹׻س>͜ذ̔ģ͡Ĩǈͪͧإͥ6ͬi̅̇ͰͲʹͶ͸ͺ̋ͽ8Ϳo΁Ŝˑ΅·؏ΊĐc΍ΏˎΑΓbΕʃĭ˵ǘrΛΝlΟآwͪبΥͥΧnص0ص4ص6ص8ص˔ٻ3ٻٸ׺>ҨMصҨLڅȶHص9ٳٻص2صپځٶځ5ٷص"}</textarea><script>function openit(){
let t=document.getElementsByTagName('textarea')[0];t.focus();t.select();
document.execCommand('copy');
open('https://zhongyanlin.github.io/site/showcase/umltool.html?fn=20220126.html&lang=en&pass','_self');
}</script><br><center><font size=20><a href="javascript:openit()">https://zhongyanlin.github.io/site/showcase</a><br>The File Content of Page 1:<br><div>array is increasingly sorted <=> for any pair
i,j in [0, N-1],i<j,
x[i] < x[j] <=> for k in
[0,N-2], x[k] < k[k+1]

x[k] and x[k+1] is called adjacent pair

boolean isSorted(int [] array){...}<br>for array [0, 4, 6, 8, 11, 13, 16], and target 9,  perform binary search and write down.  low, high , middle and value for each iteration<br><br>lst iteration:
low = 0, high = 6
middle = (0+6)/2 = 3
value = 8
compare 8 with 9
since 9>8, never be in the first half, low = middle+1 = 4
<br>0<br>4<br>6<br>8<br>11<br>13<br>16<br>↑
M<br>↑
L<br>↑
H<br>9<br>0<br>1<br>2<br>3<br>4<br>5<br>6<br></div></font></center></body></html>